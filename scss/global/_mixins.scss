@use "settings" as s;
@use "functions" as f;
@use "sass:meta";
@use "sass:map";

// font-family
@mixin font(
  $fontFamily: nth(map-get(s.$fontList, primary), 1),
  $fontWeight: nth(map-get(s.$fontList, primary), 2)
) {
  font-family: nth(map-get(s.$fontList, $fontFamily), 1);
  font-weight: $fontWeight;
}

// keyframesアニメーション
@mixin keyframes($name) {
  @-webkit-keyframes #{$name} {
    @content;
  }
  @keyframes #{$name} {
    @content;
  }
}

// :hover時のアクションをタッチデバイスには適用させない
@mixin hover {
  @media (hover: none) {
    -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
    // スマホ時にもhoverスタイルを当てたかったらここのコメントアウトを解除
    // &:active {
    //   @content;
    // }
  }
  @media (-ms-high-contrast: none),
    (-ms-high-contrast: active),
    (-moz-touch-enabled: 0),
    (hover: hover) {
    &:hover {
      @content;
    }
  }
}
// マーカー下線
@mixin marker($color: #fff7bc) {
  background: rgba(0, 0, 0, 0) linear-gradient(transparent 60%, $color 0%)
    repeat scroll 0 0;
}
// グラデーション背景
@mixin gradient(
  $colorStart: map-get(s.$colorList, primary),
  $colorEnd: map-get(s.$colorList, secondary),
  $deg: 180deg,
  $opacityStart: 1,
  $opacityEnd: 1
) {
  background: linear-gradient(
    $deg,
    rgba($colorStart, $opacityStart) 0%,
    rgba($colorEnd, $opacityEnd) 100%
  );
  filter: progid:DXImageTransform.Microsoft.gradient( startColorstr=#{$colorStart}, endColorstr=#{$colorEnd},GradientType=1 );
}

// メディアクエリ用mixin。settingsの$breakpointsのmapキーを第一引数に指定する（既定値はs）
// 第一引数が一文字の場合、max-widthの@mediaを出力。二文字の場合は分割してmin-width,max-widthの範囲で@mediaを出力
// 第二引数は第一引数が一文字の場合に「min」指定でmin-widthを出力する（オプション的役割）
// 使用方法：@include mq(s){}、mq(sm){}、mq(l,min){}など
@mixin mq($bpString: s, $minmax: max) {
  // 第一引数の文字列を格納する配列
  $bpArr: ();
  // ブレークポイントのmap
  $bpList: s.$breakpoints;
  // 第一引数の文字数をカウントしてループ
  @for $i from 1 through str-length($bpString) {
    //冒頭で宣言した空配列に、分割した文字列を格納していく（配列化したいので）
    $bpArr: append($bpArr, str-slice($bpString, $i, $i));
  }
  @if (length($bpArr) == 1) {
    // 配列の要素が1つだったら(1文字だったら)
    $int: 1;
    @if ($minmax == min) {
      $int: 0;
    }
    @media (#{$minmax}-width: (map-get($bpList,#{$bpArr}) - $int)) {
      @content;
    }
  } @else if(length($bpArr) == 2) {
    // 配列の要素が2つだったら(2文字だったら)
    @media (min-width: (map-get($bpList,#{nth($bpArr,1)}))) and (max-width: (map-get($bpList,#{nth($bpArr,2)}) - 1)) {
      @content;
    }
  }
}
